{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="{% static 'flashdeck/images/Logo.png' %}" type="image/x-icon">
    <link rel="stylesheet" href="{% static 'flashdeck/css/styles.css' %}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap"
        rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Decks | FlashDeck</title>
</head>

<body>
    <!-- NAVBAR -->
    <nav class="navbar fixed-top navbar-dark bg-black navbar-expand-lg rounded-bottom-2">
        <div class="container-fluid">
            <a href="/" class="navbar-brand">
                <img src="{% static 'flashdeck/images/Logo.png' %}" class="img-fluid" alt="." width="60" height="60">
                <p class="d-inline" id="flashdeckTitleNav">FLASHDECK</p>
            </a>
            <button class="navbar-toggler border" id="navbarToggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a href="{% url 'cardset_list' %}" class="nav-link active">My Decks</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="{% url 'account' %}">Account</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- END NAVBAR -->

  <!-- Main Content -->
  <div class="container d-flex flex-column align-items-center main-content">
    <!-- Confidence Buttons -->
    <div class="confidence-buttons d-flex justify-content-center">
      <div class="confidence-level text-center mx-2">
        <div class="confidence-container">
          <button class="confidence-button" onclick="incrementCount(this, 'Confident')">0</button>
          <div onclick="incrementCount(this.previousElementSibling, 'Confident')">Confident</div>
        </div>
      </div>
      <div class="confidence-level text-center mx-2">
        <div class="confidence-container">
          <button class="confidence-button" onclick="incrementCount(this, 'Good')">0</button>
          <div onclick="incrementCount(this.previousElementSibling, 'Good')">Good</div>
        </div>
      </div>
      <div class="confidence-level text-center mx-2">
        <div class="confidence-container">
          <button class="confidence-button" onclick="incrementCount(this, 'Needs Work')">0</button>
          <div onclick="incrementCount(this.previousElementSibling, 'Needs Work')">Needs Work</div>
        </div>
      </div>
      <div class="confidence-level text-center mx-2">
        <div class="confidence-container">
          <button class="confidence-button" onclick="incrementCount(this, 'Again')">0</button>
          <div onclick="incrementCount(this.previousElementSibling, 'Again')">Again</div>
        </div>
      </div>
    </div>
    <p class="mt-3" style="color: #ffffff">Number of reviews this session: <span id="flipCounter">0</span></p>

    <!-- Dynamically generate cards from the database -->
      <div class="card" id="card-{{ forloop.counter }}" data-card-id="{{ card.card_setNumber }}">
        <!-- Front of the card -->
        <div class="prototype-box front d-flex align-items-center justify-content-center text-center">
          <p class="card-text">{{ card.question }}</p>
        </div>

        <!-- Back of the card -->
        <div class="prototype-box back d-flex flex-column align-items-center justify-content-center text-center">
          <p>{{ card.answer }}</p>
        </div>
      </div>
  </div>
  <!-- End Main Content -->

  <!-- Footer -->
  <div class="container-fluid mt-5" id="footer">
    <div class="row">
      <div class="col text-center text-white">
        <p id="footerHeader">FLASHDECK</p>
      </div>
    </div>
    <div class="row">
      <div class="col text-center text-white">
        <div id="footerLoremIpsum">
          <p>Lorem Ipsum dolor sit amet consectetur adipisicing elit. Ratione veniam</p>
          <p>amet autem sunt. perspiciatis nemo.</p>
        </div>
      </div>
    </div>
    <div class="row mb-1">
      <div class="col d-flex justify-content-center" id="footerLogos">
        <a href="https://www.facebook.com/"><img class="img-fluid mx-1"
            src="{% static 'flashdeck/images/facebook-icon.png' %}" style="width: 25px; height: 25px"
            alt="Facebook"></a>
        <a href="https://www.instagram.com"><img class="img-fluid mx-1"
            src="{% static 'flashdeck/images/instagram-icon.png' %}" style="width: 25px; height: 25px"
            alt="Instagram"></a>
        <a href="https://twitter.com/"><img class="img-fluid mx-1" src="{% static 'flashdeck/images/x-icon.png' %}"
            style="width: 25px; height: 25px" alt="X"></a>
      </div>
    </div>
    <div class="row">
      <div class="col d-flex text-white justify-content-center">
        <p id="footerLegal">Â© 2024 FlashDeck | All Rights Reserved</p>
      </div>
    </div>
  </div>
  <!-- End Footer -->

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous">
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      async function fetchStudyCards() {
        const deckId = getDeckIdFromURL();
        console.log(`Deck ID: ${deckId}`);
        try{
          const response = await fetch(`api/study-cards/${deckId}/`);
          const data = await response.json();
          console.log('API Response:', data);
          cardsData = data.cards; 
          if (cardsData.length === 0) {
            console.error('No cards found for this quiz.');
            alert('No cards available for this deck.');
            return;
          } 
        } catch (error) {
          console.error(`Failed to fetch study cards: `, error )
        }
        
      }

      function getDeckIdFromURL() {
        const path = window.location.pathname;
        const parts = path.split('/'); 
        return parts[2];
      }

      let flipCount = 0;
      let currentIndex = 0;
      let cards = fetchStudyCards();
      console.log(cards);  //is a promise right now, needs to be an object
      let confidenceCounts = {};
      let deckCycle = 1;

      // Confidence level mapping
      const confidenceLevels = {
        'Confident': 1,
        'Good': 2,
        'Needs Work': 3,
        'Again': 4,
        'Unrated': 3  // Default value
      };

      // Function to get CSRF token from cookies
      function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
          const cookies = document.cookie.split(';');
          for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
            }
          }
        }
        return cookieValue;
      }
      const csrfToken = getCookie('csrftoken');

      // Initialize cards
      cards.forEach((card, index) => {
        card.style.zIndex = cards.length - index;
        if (index !== 0) {
          card.classList.add('hidden');
        }
      });

      // Event listener for keydown (flip card with spacebar)
      document.addEventListener("keydown", function (event) {
        if (event.code === "Space") {
          event.preventDefault();
          const card = cards[currentIndex];
          card.classList.toggle("flip");
          flipCount++;
          document.getElementById("flipCounter").textContent = flipCount;
        }
        if (event.code === "Enter") {
          event.preventDefault();
          alert('Please select a confidence level before proceeding.');
        }
      });

      function incrementCount(button, confidenceLevel) {
        const currentValue = parseInt(button.textContent);
        button.textContent = currentValue + 1;

        const currentCard = cards[currentIndex];
        const cardId = currentCard.id;

        if (!confidenceCounts[cardId]) {
          confidenceCounts[cardId] = {
            'Confident': 0,
            'Good': 0,
            'Needs Work': 0,
            'Again': 0
          };
        }
        confidenceCounts[cardId][confidenceLevel] += 1;
        if (deckCycle === 1) {
          moveToNextCard();
        } else {
          if (confidenceLevel === 'Confident' && confidenceCounts[cardId]['Confident'] >= 3) {
            displayStars(currentCard);

            setTimeout(function () {
              cards.splice(currentIndex, 1);

              currentCard.parentNode.removeChild(currentCard);

              if (currentIndex >= cards.length) {
                currentIndex = 0;
              }

              if (cards.length > 0) {
                cards.forEach((card, index) => {
                  card.style.zIndex = cards.length - index;
                  card.classList.toggle('hidden', index !== currentIndex);
                });
              } else {
                alert('Congratulations! You have completed the study session.');
              }
            }, 2000);
          } else {

            cards.splice(currentIndex, 1);

            let newPosition;
            if (confidenceLevel === 'Again') {
              newPosition = currentIndex + 1;
            } else if (confidenceLevel === 'Needs Work') {
              newPosition = currentIndex + 3;
            } else if (confidenceLevel === 'Good') {
              newPosition = currentIndex + 5;
            } else if (confidenceLevel === 'Confident') {
              newPosition = cards.length;
            } else {
              newPosition = cards.length;
            }

            if (newPosition > cards.length) {
              newPosition = cards.length;
            }

            cards.splice(newPosition, 0, currentCard);

            const cardContainer = document.querySelector('.main-content');
            cards.forEach(card => {
              cardContainer.appendChild(card);
            });

            currentCard.classList.remove('flip');

            if (newPosition <= currentIndex) {
              currentIndex++;
            }
            if (currentIndex >= cards.length) {
              currentIndex = 0;
            }

            cards.forEach((card, index) => {
              card.style.zIndex = cards.length - index;
              card.classList.toggle('hidden', index !== currentIndex);
            });
          }
        }

        if (currentIndex === 0) {
          deckCycle++;
          if (deckCycle === 2) {
            reshuffleDeck();
          }
        }
      }

      function moveToNextCard() {
        cards[currentIndex].classList.add('hidden');
        currentIndex++;

        if (currentIndex >= cards.length) {
          currentIndex = 0;
          deckCycle++;

          if (deckCycle === 2) {
            reshuffleDeck();
          }
        }

        cards.forEach((card, index) => {
          card.classList.toggle('hidden', index !== currentIndex);
        });
      }

      function reshuffleDeck() {
        // Map card indices to confidence levels
        const cardData = cards.map((card) => {
          const cardId = card.dataset.cardId;
          const confidenceData = confidenceCounts[card.id] || {};
          const confidenceLevelStr = getCardConfidenceLevel(confidenceData);
          const confidenceValue = confidenceLevels[confidenceLevelStr];

          return {
            card: card,
            card_id: cardId,
            confidenceLevelStr: confidenceLevelStr,
            confidenceValue: confidenceValue
          };
        });

        // Sort the cards based on confidence levels
        cardData.sort((a, b) => a.confidenceValue - b.confidenceValue);

        // Update the cards array and DOM
        cards = cardData.map(data => data.card);
        const cardContainer = document.querySelector('.main-content');
        cards.forEach(card => cardContainer.appendChild(card));

        // Reset states
        currentIndex = 0;
        cards.forEach((card, index) => {
          card.style.zIndex = cards.length - index;
          card.classList.remove('flip');
          card.classList.toggle('hidden', index !== currentIndex);
        });

        // Prepare data to send to the server
        const cardUpdates = cardData.map(data => ({
          card_id: data.card_id,
          confidence_level: data.confidenceValue
        }));

        // Send data to the server
        updateCardOrder(cardUpdates);
      }

      function getCardConfidenceLevel(confidenceData) {
        let maxCount = 0;
        let maxConfidence = 'Unrated';

        for (const level in confidenceData) {
          if (confidenceData[level] > maxCount) {
            maxCount = confidenceData[level];
            maxConfidence = level;
          }
        }

        return maxConfidence;
      }

      function updateCardOrder(cardUpdates) {
        fetch("{% url 'update_card_order' %}", {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
          },
          body: JSON.stringify({ card_updates: cardUpdates })
        })
          .then(response => response.json())
          .then(data => {
            console.log('Card order updated:', data);
          })
          .catch((error) => {
            console.error('Error updating card order:', error);
          });
      }

      function displayStars(card) {
        const overlay = document.createElement('div');
        overlay.classList.add('star-overlay');

        const starContent = document.createElement('div');
        starContent.classList.add('stars');
        starContent.innerHTML = 'â­ï¸â­ï¸â­ï¸';

        overlay.appendChild(starContent);

        card.appendChild(overlay);
      }

      function adjustFontSize() {
        const box = document.querySelector(".prototype-box .card-text");
        if (box) {
          let fontSize = 24;
          box.style.fontSize = `${fontSize}px`;
          while (box.scrollHeight > box.clientHeight && fontSize > 0) {
            fontSize -= 1;
            box.style.fontSize = `${fontSize}px`;
          }
        }
      }

      document.addEventListener("DOMContentLoaded", adjustFontSize);
      window.addEventListener("resize", adjustFontSize);
    });
  </script>

</body>

</html>
